#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<stack>
#include<queue>
typedef struct Node{
 
 int data;
    struct Node *left;
    struct Node *right;
    
}node;
Node* insert(node *root,int val)
{
  if(val>=root->data)
  {
      if(root->right!=NULL)
      insert(root->right,val);
      else{
         node *tmp=(node*)(malloc(sizeof(node)));
         tmp->data=val;
          root->right=tmp;
      }
  }
  else  if(val<root->data)
    {
       if(root->left!=NULL)
       insert(root->left,val);
       else{
         node *tmp=(node*)(malloc(sizeof(node)));
          tmp->data=val;
          root->left=tmp;
        }
    }  
} 
void traverseInOrderStack(node * root)
{
     std::stack<node*> st;
     node *curr=root;
     while(curr||!st.empty())
     {

         while(curr)
         {  
             
            
             st.push(curr);
            
             curr=curr->left;
         }
         curr=st.top();
         st.pop();                    
       std::cout<<curr->data<<"  ";
         curr=curr->right;
     }
}
void traversePreOrderStack(node * root)
{
     std::stack<node*> st;
     node *curr=root;
     while(curr||!st.empty())
     {

         while(curr)
         {  
             
            
             st.push(curr);
             std::cout<<curr->data<<"  ";
             curr=curr->left;
         }
         curr=st.top();
         st.pop();                    
      
         curr=curr->right;
     }
}
void traverseInOrder(node * node) {
       
        if (node == NULL) 
        return;
       
            traverseInOrder(node->left);
        
            std::cout<<node->data<<"  ";
            traverseInOrder(node->right);
       
    
} 
   
 
void traversePostOrderStack(node *root)
{
      std::stack<node*> st,result; 
   node *curr;
    st.push(root);
    while(!st.empty())
    {
        curr=st.top();
        st.pop();
        result.push(curr);
        if (curr->left) 
            st.push( curr->left); 
        if (curr->right) 
            st.push(curr->right); 
        
    }
    while(!result.empty())
    {
        std::cout<<result.top()->data<<"  ";
        result.pop();
    }
}
void traverseOrderLevel(node *root)
{
    std::queue<node*> q; 
   node *curr;
    q.push(root);
    while(!q.empty())
    {
        curr=q.front();
        q.pop();
        std::cout<<curr->data<<"  ";
       
        if (curr->left) 
            q.push( curr->left); 
        if (curr->right) 
            q.push(curr->right); 
        
    }
    
}
 node* searchBST(node* root, int val) {
     
        while(root!=NULL)
        {
            if(root->data==val)
                return root;
            if(val>root->data)
                root=root->right;
        else     if(val<root->data)
                root=root->left;
            
        }
        return root;
    
}    
 
int main()
{
    node *root=(node*)(malloc(sizeof(node)));
    root->data=3;
     insert(root,9);
    insert(root,20);
    insert(root,15);
  
    insert(root,7);
   insert(root,2);
    insert(root,1);
    // insert(root,27);
    //   insert(root,0);
      
   traverseInOrder(root);
   
   return 0;
}
